// func (RBN *RedAndBlackTreeNode) Delete(value int){

// 	if RBN == nil {
// 		return 
// 	}
	
// 	if RBN.Value == value {
		
// 		//leaf node
// 		//no children
// 		if !RBN.hasLeftChild() && !RBN.hasRightChild(){
				
// 			if RBN.isBlack(){

// 					if (RBN.Left.isRed() || RBN.Right.isRed()){
// 						if RBN.Left.isRed(){
// 							node := RBN.Parent
// 							RBN = RBN.Parent
// 							RBN.Right = node

// 							RBN.Left.Color = "Black"
// 							RBN.Right.Color = "Black"
// 						}

// 						if RBN.Right.isRed(){
// 							node := RBN.Parent
// 							RBN = RBN.Parent
// 							RBN.Left = node

// 							RBN.Right.Color = "Black"
// 							RBN.Left.Color = "Black"
// 						}
// 						if RBN.Left.isBlack() || RBN.Right.isBlack(){
// 							RBN.Color = "Black"
// 						}
// 					}

// 					if RBN.isRed(){
// 						if RBN.hasLeftChild() && RBN.hasRightChild(){
// 							if RBN.Left.isBlack() || RBN.Right.isBlack(){

// 							}
// 						}
// 					}
// 				}
// 		}

// 		//RBN has at most one internal child
// 		if RBN.hasLeftChild() && !RBN.hasRightChild() || !RBN.hasLeftChild() && RBN.hasRightChild() || !RBN.hasLeftChild() && RBN.hasRightChild(){
// 			if RBN.hasLeftChild(){
// 				RBN = RBN.Left
// 				RBN.Color = "Black"
// 				return
// 			}
// 			if RBN.hasRightChild(){
// 				RBN = RBN.Right
// 				RBN.Color = "Black"
// 				return
// 			}
// 		}

// 		//two children
// 		if RBN.hasLeftChild() && RBN.hasRightChild(){

// 			node := RBN.Left.Right

// 			for node.Right != nil{
// 				node = node.Right
// 			}
// 			temp := node 
// 			node = RBN
// 			RBN = node
// 			node = nil

// 	}

// 	if RBN.Value > value{
// 		if RBN.hasLeftChild(){
// 			RBN.Delete(value)
// 		}
// 	}

// 	if RBN.Value < value{
// 		if RBN.hasRightChild(){
// 			RBN.Delete(value)
// 		}
// 	}
// }
// }


////////////LinkedList


// func isLess[T comparable](val1 T, val2 T)(bool){

// 	if val

// 	switch val.(type){
// 	case struct:
// 		if val1 < val2{
// 			return true
// 		}else{
// 			return false
// 		}
// 	case float64:
// 		if val1 < val2{
// 			return true
// 		}else{
// 			return false
// 		}
// 	case
// 	}
	
// }



func (RBN *RedAndBlackTreeNode) Rebalance(direction string){
	
			//parent		//child 			//aunt/Uncle
		if RBN.isRed() && RBN.Left.isRed() && RBN.Parent.Left.isBlack(){
			//Right Rotation
			node := RBN
			RBN = RBN.Left
			RBN.Right = node
			
			//LeftRotation
			newNodeParent := RBN.Parent
			newNodeLeft:= RBN.Left
			RBN.Left = newNodeParent
			newNodeParent.Left = newNodeLeft

			//Recolor
			RBN.Color = Black
			RBN.Left.Color = Red 
			RBN.Right.Color = Red
		}
		//newly inserted node has a black aunt/uncle
		//

		if RBN.Parent.Left.isRed(){
			RBN.Color = Black
			RBN.Parent.Left.Color = Black
		}
		if RBN.Parent.Left.isBlack(){
			//Right - Left Rotation
			oldParent := RBN.Parent
			nodeLeft := RBN.Left
			RBN.Parent = RBN
			RBN.Left = oldParent 
			RBN.Left.Right = nodeLeft
			
		}
}


////////////Tries
// func TestTrieDelete(t *testing.T){

// 	var TT Trie

// 	for _, test :=range testWordValues{
// 		TT.Insert(test)
// 	}

// 	for _,test := range testWordValues{
// 		TT.Delete(test)
// 		found := TT.Search(test)

// 		if found{
// 			t.Errorf("Expected %v to not be in the Trie", test)
// 		}

// 	}

// 	if TT.Size != 0{
// 		t.Errorf("Expected Trie to be empty, Instead got %v", TT.Size)
// 	}
// }


///////////////LinkedList
func TestReverse(t *testing.T){

	var LL LinkedList
	var TestLL LinkedList
	for _, test := range testValues{
		LL.AddEnd(test)
	}
	for _, test := range testValues{
		TestLL.AddFront(test)
	}

	LL.Reverse()

	onode := LL.Head
	testNode := TestLL.Head

	for index := range testValues{

		if onode != testNode{
			t.Errorf("Expected these nodes to be equal, Expected %v, got %v", onode.Value, testNode.Value)
		}

		if onode.Value != testValues[len(testValues) -1 -index]{
			t.Errorf("Expected node value to match with corresponding testValues position, Expected:%v, got: %v", testValues[len(testValues) -1 -index],onode.Value)
		}

		onode = onode.Next 
		testNode = testNode.Next
	}

}